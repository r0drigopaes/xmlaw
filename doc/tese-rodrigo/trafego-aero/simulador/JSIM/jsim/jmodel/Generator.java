/******************************************************************
 * 
 * @(#) Generator.java     1.1
 * 
 * Copyright (c) 2005, John Miller, Junxiu Tao
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *   
 * 1. Redistributions of source code must retain the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer. 
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution. 
 * 3. Neither the name of the University of Georgia nor the names
 *    of its contributors may be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @version     1.3, 28 Jan 2005
 * @author      John Miller, Junxiu Tao, Greg Silver
 */

package jsim.jmodel;

import java.io.*;
import java.util.*;
import java.util.logging.*;

import jsim.util.*;


/******************************************************************
 * The Generator class generates code for JSIM models.
 * All methods should be static.
 */

public class Generator 
{
    //////////////////////// Constants \\\\\\\\\\\\\\\\\\\\\\\\\\\\

    //////////////////////// Variables \\\\\\\\\\\\\\\\\\\\\\\\\\\\
    /**
     * Name of the simulation model
     */
    private static String      mName;   

    /**
     * Number of nodes
     */
    private static int         numNodes;

    /**
     * Array of nodes
     */
    private static Node []     node; 

    /**
     * List of entity type names (e.g., Customer)
     */
    private static ArrayList<String> entTypeList = new ArrayList<String> ();

    /**
     * List of Transport names 
     */
    private static ArrayList<String> transList = new ArrayList<String> ();

    /**
     * Whether each node has been marked
     */
    private static boolean []  marked;

    /**
     * Nodes at yet unseen
     */
    private static int []      unseen;

    /**
     * Special queue to hold nodes visited
     */
    private static QueueSet    nodeQueue;

    /**
     * If sign counter
     */
    private static int         ifSign;

	/**
	 * Split indicator
	 */
	private static int         startNodeType;

    /**
     * Directory in which to generate code
     */
     private static String currDir;
     
     /**
      * File separator charcter
      */
      private static String SLASH;

    /**
     * Tracing messages
     */
	private static Logger trc;
    // private static Trace       trc;


    /**************************************************************
     * Emit code for model mName.  Files will be created for
     * the Model Applet (e.g., BankApp.java)  and Model (Bank.java).
     * In addition, one file will be created for each entity type
     * (e.g., Customer.java) as generated by a source node.
     *-------------------------------------------------------------
     * @param  mName     name of simulation model (e.g., Bank)
     * @param  node      array of nodes making up the model
     * @param  numNodes  number of nodes
     */
    static void emitCode (String mName, Node [] node, int numNodes)
    {
        Generator.mName    = mName;
        Generator.node     = node;
        Generator.numNodes = numNodes;
		trc = Logger.getLogger(Generator.class.getName() );
		Trace.setLogConfig ( trc );
       // trc       = new Trace  ("Generator", mName);

        marked    = new boolean [numNodes];
        unseen    = new int     [numNodes];
    
        nodeQueue = new QueueSet (10 * numNodes);

		trc.info ( "for " + mName );
        // trc.show ("emitCode", "for " + mName);

        currDir = NetFrame.currDir;
	SLASH = System.getProperty("file.separator");

        int numSources = 0;

        genModelHtml ();      // applet html for model
        genModelApp ();       // applet driver for model
//      genModelBean ();      // bean driver for model (ModelBean is not supported in this release.)

        for (int i = 0; i < numNodes; i++) {
            if (node [i].nodeType == Node.SOURCE || node [i].nodeType == Node.SPLIT) {
				if (node [i].nodeType == Node.SOURCE) 
				{
					numSources++;
				} // if
                genEntity (i);
            }; // if
        }; // for

        genModel ();          // main simulation model frame

        if (numSources <= 0) {
			trc.warning ( "numSources = " + numSources );
            // trc.tell ("emitCode", "numSources = " + numSources);
        }; // if
		
		trc.info ( "code generation complete" );
        // trc.show ("emitCode", "code generation complete");

    }; // emitCode


    /**************************************************************
     * Generate the applet file for the model (e.g., BankApp.java).
     */
    private static void genModelHtml ()
    {
        String fileName = new String (currDir + SLASH + mName + ".html");
	System.out.println("**********************" + fileName + "********************************");

        try {
            FileWriter fout = new FileWriter (fileName);

            fout.write (

        "<HTML>\n" +
        "<BODY>\n" +
//      "<APPLET CODE = " + mName + "App.class CODEBASE = \".\" ARCHIVE = \"" + mName + "Fed.jar\" Width = 100 height = 50> </APPLET>\n" +
       "<APPLET CODE = " + mName + "App.class CODEBASE = \".\" ARCHIVE = \"" + mName + ".jar\" Width = 100 height = 50> </APPLET>\n" + 
        "</BODY>\n" +
        "</HTML>\n" );

            fout.close();

        } catch (IOException e) {
			trc.warning ( "can't write " + fileName );
            // trc.tell ("genModelHtml", "can't write " + fileName);
        }; // try

    }; // genModelHtml


    /**************************************************************
     * Generate the applet file for the model (e.g., BankApp.java).
     */
    private static void genModelApp ()
    {
        String fileName = new String (currDir + SLASH + mName + "App.java");

        try {
            FileWriter fout = new FileWriter (fileName);

            fout.write (

        "\n" +
        "/*****************************************************************\n" +
        " * " + mName + "App.java\n" +
        " * JSIM Applet for " + mName + " simulation model\n" +
        " */\n" +
        "\n" +
        "import java.applet.*;\n" +
        "\n" +
        "public class " + mName + "App extends Applet\n" +
        "{\n" +
        "\t/*********************************************************\n" +
        "\t * Construct applet.\n" +
        "\t */\n" +
        "\tpublic " + mName + "App ()\n" +
        "\t{\n" +
        "\t\t" + mName + " model = new " + mName + " ();\n" + 
        "\t\tmodel.start ();\n" +
        "\n" +
        "\t}; // " + mName + "App\n" +
        "\n" +
        "}; // class\n" +
        "\n" );
    
            fout.close ();

        } catch (IOException e) {
			trc.warning ( "can't write " + fileName );
            // trc.tell ("genModelApp", "can't write " + fileName);
        }; // try

    }; // genModelApp


    /**************************************************************
     * Generate code for entities (e.g., Customer.java) created from
     * source snum.
     *-------------------------------------------------------------
     * @param  snum  index of a source node
     */
    private static void genEntity (int snum)
    {
        String entityName = node [snum].nodeName;
        String fileName   = new String (currDir + SLASH + entityName + ".java");

        entTypeList.add (entityName);

        try {
            FileWriter fout = new FileWriter (fileName);

            fout.write (

        "\n" +
        "/******************************************************************\n" +
        " * " + entityName + ".java\n" +
        " * JSIM " + entityName + " entity\n" +
        " */\n" +
        "\n" +
        "import jsim.process.*;\n" +
        "import jsim.variate.*;\n" +
        "\n" +
        "\n" +
        "public class " + entityName + " extends SimObject\n" +
        "{\n" +
        "\tstatic " + mName + " e_;\n" +
        "\n" +
	"\tpublic void setEnvironment (Model env)\n" +
	"\t\t{ e_ = (" + mName  + ") env; }\n" +
	"\n" +
	"\tpublic Model getEnvironment ()\n" +
	"\t\t{ return e_; }\n" +
	"\n" +	
        "\tpublic void run ()\n" +
        "\t{\n" +
//      "\t\tVariate\tbranch = new Variate (0);\n" +
        "\n" +
        "\t\ttry {\n" +
        genRunMethod (snum) +
        "\t\t} catch (EntityException ee) { _end (); };\n" +
        "\n" +
        "\t}; // run\n" +
        "\n" +
        "}; // class\n" +   
        "\n" );

            fout.close ();

        } catch (IOException e) {
			trc.warning ( "can't write " + fileName );
            // trc.tell ("genEntity", "can't write " + fileName);
        }; // try
   
    }; // genEntity


    /**************************************************************
     * Generate the run method for entities created from source snum.
     *-------------------------------------------------------------
     * @param   snum    index of a source node
     * @return  String  code for run method
     */
    private static String genRunMethod (int snum)
    {
        String buf       = new String ();
        int    ifCounter = 0 ;
        double ifValue   = 0.0;

        ifSign = 0;
		startNodeType = node [snum].nodeType;

        nodeQueue.reset ();
        enqueueNode (snum);       // start from a source node
        nodeQueue.organize ();

        for (int i = 0; i < numNodes; i++) {
            marked [i] = false;
            unseen [i] = node [i].numInEdges;
			trc.info ( "unseen [" + i + "] = " + unseen [i] );
			// trc.show ("genRunMethod", "unseen [" + i + "] = " + unseen [i]);
        }; // for

        if (nodeQueue.dequeue () != snum) {
			trc.warning ( "source " + snum + " not dequeued" );
            // trc.tell ("genRunMethod", "source " + snum + " not dequeued");
            return buf;
        }; // if

        // call recursive method
		if (node[snum].nodeType == Node.SPLIT) 
		{
			buf = genCloneRunNode (snum, ifCounter, ifValue, buf, true);
		} 
		else 
		{
			buf = genRunNode (snum, ifCounter, ifValue, buf);
		} // if

        if (ifSign > 0) {
            for (int k = 0; k < ifSign; k++) {
                buf = buf.concat ("\n\t\t}; // if\n\n");
            }; // for
        }; // if

        trc.info ( "ifSign = " + ifSign );
		// trc.show ("genRunMethod", "ifSign = " + ifSign);

        return buf;

    }; // genRunMethod


    /**************************************************************
     * Add the node with index i to the nodeQueue and call this
     * method recursively to add nodes out adjacent to it.
     *-------------------------------------------------------------
     * @param  i  index of node
     */
    private static void enqueueNode (int i)
    {
        int lastEdge;
		int firstEdge = 0;
		Node n = node [i];
        nodeQueue.enqueue (i);	
        boolean wellFormed = true;
        if (n.nodeType == Node.SINK) {
            wellFormed = n.numOutEdges == 0;   // okay if == 0
        } else if (n.numOutEdges <= 0) {
            wellFormed = false;                // must be > 0
        }; // if
        if ( ! wellFormed) {
			trc.warning ( "numOutEdges = " + n.numOutEdges + " for " + i );
            // trc.tell ("enqueueNode",  "numOutEdges = " + n.numOutEdges + " for " + i);
        }; // if

		if (n.nodeType == Node.SPLIT && startNodeType == Node.SPLIT)    
		{
			firstEdge = 1;
			lastEdge = n.numOutEdges;
			startNodeType = Integer.MIN_VALUE;
		} 
		else if (n.nodeType == Node.SPLIT)
		{
			lastEdge = n.numOutEdges - 1;
		} 
		else 
		{
			lastEdge = n.numOutEdges;
		}// if

        for (int j = firstEdge; j < lastEdge; j++) 
		{
            enqueueNode ( getEndNode (n.outEdge [j]) );
        }; // for

    }; // enqueueNode


    /**************************************************************
     * Recursively generate run-method code for ith node.
     *-------------------------------------------------------------
     * @param   i          index of node
     * @param   ifCounter  if counter
     * @param   ifValue    if flag
     * @param   buf        code buffer
     * @return  String     code for the ith node's run-method
     */
    private static String genRunNode (int    i,
                                      int    ifCounter,
                                      double ifValue,
                                      String buf)
    {
        Node     n      = node [i];
        int      nt     = n.nodeType;
        boolean  ifFlag = false;
        Double   value = null;
		String	 cond;
        String   eName;
        int      end;
        int      npar;
        int      tmpend;
		int		 numActiveEdges;

		trc.info ( "emit run method code for node " + i + 
					"<" + n.nodeName + " [" + nt + "]");
        // trc.show ("genRunNode", "emit run method code for node " + i +
        //          "<" + n.nodeName + " [" + nt + "]");

        marked [i] = true;

        if (nt == Node.SINK) {
            if (n.numOutEdges != 0) {
				trc.warning ( "Sink node may not have outgoing Transports" );
                // trc.tell ("genRunNode", "Sink node may not have outgoing Transports");
            }; // if
        } else if (n.numOutEdges <= 0) {
			trc.warning ( "node " + Node.TYPE_NAME [nt] 
							+ " must have outgoing Transports");
            // trc.tell ("genRunNode", "node " + Node.TYPE_NAME [nt] +
            //          " must have outgoing Transports");
        }; // if

        /**********************************************************
         * Generate run method code for node n itself.
         */
        switch (nt) {

        case Node.SERVER:
        case Node.FACILITY:
            buf = buf.concat ("\t\t\te_." + n.nodeName + ".request (this);\n");
			buf = buf.concat ("\t\t\te_." + n.nodeName + ".use (this);\n");
			break;
        case Node.SINK:
		case Node.SPLIT:
		case Node.ANDJOIN:
            buf = buf.concat ("\t\t\te_." + n.nodeName + ".use (this);\n");
            break;
        case Node.SIGNAL:
        case Node.SOURCE:
            break;         // exogeneous to entity

        default:
			trc.warning ( "illegal node type " + nt );
            // trc.tell ("genRunNode", "illegal node type " + nt);
        }; //switch

        /**********************************************************
         * Generate run method code for node n's outgoing edges.
         */
		trc.info ( "numOutEdges = " + n.numOutEdges );
        // trc.show ("genRunNode", "numOutEdges = " + n.numOutEdges);
        if (n.numOutEdges > 1 && nt != Node.SPLIT) {
            ifFlag = true;
            ifCounter++;
        }; // if
		trc.info ( "ifFlag = " + ifFlag + " ifCounter = " + ifCounter );
        // trc.show ("genRunNode", "ifFlag = " + ifFlag + " ifCounter = " + ifCounter);

		if (nt == Node.SPLIT)      // skip the fist edge of a split
		{
			numActiveEdges = n.numOutEdges - 1;
		} 
		else 
		{
			numActiveEdges = n.numOutEdges;
		} // if

			/**********************************************************
			 * Generate the correct if-elseif-else relation.
			 */
		
			for (int j = 0; j < numActiveEdges; j++) 
			{

				end = getEndNode (n.outEdge [j]);
				unseen [end]--;

				trc.info ( "Edge " + j + " = (" + i + ", " + end + ")" );
				// trc.show ("genRunNode", "Edge " + j + " = (" + i + ", " + end + ")");
            
				if (ifFlag) 
				{

					/**************************************************
					 * First out edge.
					 */
					if (j == 0) 
					{
						switch (n.outEdge [j].getOutCondType ())
						{
							case Parameters.PROBABILITY_TYPE: 
								value   = new Double (n.outCondition [0]);
								ifValue = value.doubleValue ();

								buf  = buf.concat (
									"\n\t\tdouble "  + Parameters.OUT_COND_FIELD [Parameters.PROBABILITY_TYPE] + ifCounter + " = branch.gen ();\n" +
									"\t\tif (" + Parameters.OUT_COND_FIELD [Parameters.PROBABILITY_TYPE] + ifCounter + " < " + n.outCondition [0] + ") {\n\n");
								break;
							case Parameters.CLASS_ID_TYPE:
								cond	= n.outCondition [0];
								value   = new Double (0);
								ifValue = value.doubleValue ();

								buf  = buf.concat (
									"\n\t\tdouble "  + Parameters.OUT_COND_FIELD [Parameters.PROBABILITY_TYPE] + ifCounter + " = branch.gen ();\n" +
									"\n\t\tif (" + Parameters.OUT_COND_FIELD [Parameters.CLASS_ID_TYPE]+ " " + n.outCondition [0] + ") {\n\n");
								break;
							case Parameters.COST_TYPE:
								cond	= n.outCondition [0];
								value   = new Double (0);
								ifValue = value.doubleValue ();

								buf  = buf.concat (
									"\n\t\tdouble "  + Parameters.OUT_COND_FIELD [Parameters.PROBABILITY_TYPE] + ifCounter + " = branch.gen ();\n" +
									"\n\t\tif (" + Parameters.OUT_COND_FIELD [Parameters.COST_TYPE] + " " + n.outCondition [0] + ") {\n\n");
								break;
						}
						ifSign++;

						/**************************************************
						 * Last out edge.
						 */
					} 
					else if (j < n.numOutEdges - 1) 
					{
						if (n.outEdge [j].getOutCondType ()== 0)
						{
							value    = new Double (n.outCondition [j]);
							ifValue += value.doubleValue ();
							value    = new Double (ifValue);
						} // if
						npar     = ifSign - ifCounter;

						if (npar == -1 ) 
						{
							switch (n.outEdge [j].getOutCondType ())
							{
								case Parameters.PROBABILITY_TYPE: 
									buf = buf.concat (
										"\n\t\t else if (prob" + ifCounter + " < " + value.toString () + ") {\n\n" );
									break;
								case Parameters.CLASS_ID_TYPE:
									buf = buf.concat (
										"\n\t\t else if (simClassId " + n.outCondition [j] + ") {\n\n" );
									break;
								case Parameters.COST_TYPE: 
									buf = buf.concat (
										"\n\t\t else if (simCost " + n.outCondition [j] +  ") {\n\n" );
									break;

							} // switch
						}		
						else if (npar >= 0 ) 
						{
							for (int k = 0; k < npar - 1; k++) 
							{
								buf = buf.concat (" }");
							}; // for
							switch (n.outEdge [j].getOutCondType ())
							{
								case Parameters.PROBABILITY_TYPE:
									buf = buf.concat (
										"\n\t\t} else if (prob" + ifCounter + " < " + value.toString () + ") {\n\n" );
									break;
								case Parameters.CLASS_ID_TYPE:
									buf = buf.concat (
										"\n\t\t} else if (simClassId " + n.outCondition [j] + ") {\n\n" );
									break;
								case Parameters.COST_TYPE:
									buf = buf.concat (
										"\n\t\t} else if (simCost " + n.outCondition [j] + ") {\n\n" );
									break;

							} // switch
						} 
						else 
						{
							trc.warning ( "malformed graph" );
							// trc.tell ("genRunNode", "malformed graph");
						}; // if

						/**************************************************
						 * Other out edges.
						 */
					} 
					else 
					{
						npar = ifSign - ifCounter;
						if (npar == -1) 
						{
							buf = buf.concat ("\n\t\t else {\n\n");
						} 
						else if (npar >= 0) 
						{
							for (int k = 0; k < npar - 1; k++) 
							{
								buf = buf.concat (" }");
							}; // for
							buf = buf.concat ("\n\t\t} else {\n\n");
						} 
						else 
						{
							trc.warning ( "malformed graph" );
							// trc.tell ("genRunNode", "malformed graph");
						}; // if

					}; // if

				}; // if

				/**********************************************************
				 * Generate code move along transport.
				 */
				eName = new String (n.nodeName + "E" + j);

				buf = buf.concat (

					"\t\t\tfor (e_." + eName + ".join (this);\n" +
					"\t\t\t     e_." + eName + ".move (this); );\n" );

				if (node [end].nodeType == Node.SINK) 
				{
					trc.info ( "sink = " + end + ", " + marked [end] +
								", " + unseen [end]); 
					// trc.show ("genRunNode", "sink = " + end + ", " + marked [end] +
					//	", " + unseen [end]); 
				}; // if

				/**********************************************************
				 * Decide the next node should be generated.
				 */
				if ( ! marked [end]) 
				{
					trc.info ( "unseen [" + end + "] = " + unseen [end] );
					// trc.show ("genRunNode", "unseen [" + end + "] = " + unseen [end]);
					tmpend = nodeQueue.getFront ();
					if (tmpend < 0) 
					{
						tmpend = - tmpend - 1;
					}; // if

					if (tmpend == end) 
					{   // if next node should be generated
						if (nodeQueue.getFront () < 0 && ifSign > 0) 
						{
							buf = buf.concat ("\n\t\t}; // if\n\n");
							ifSign--;
						}; // if
						nodeQueue.dequeue ();
						buf = genRunNode (end, ifCounter, ifValue, buf);
					}; // if

					/***
					 if (unseen [end] == 0) {      // no unseen incoming edges
					 if (node [end].numInEdges > 1) {
					 buf = buf.concat ("\n\t\t}; // if\n\n");
					 ifSign--;
					 }; // if
					 buf = genRunNode (end, ifCounter, ifValue, buf);
					 }; // if
					 ***/

				}; // if

			}; // for

        return buf;

    }; // genRunNode


    /**************************************************************
     * Generate code to define inner classes, one for each entity
     * type (i.e., for each Source).
     *-------------------------------------------------------------
     * @return  String  code for inner classes
     */
    private static String defineInnerClasses (String ifBean)
    {
        String sName;
        String buf = new String ();

        for (int i = 0; i < numNodes; i++) {
             if (node [i].nodeType == Node.SOURCE) {
                 sName = node [i].nodeName;

                 buf = buf.concat (

        "\tpublic class " + sName + "Maker extends EntityMaker\n" +
        "\t{\n" +
        "\t\tpublic " + sName + "Maker (" + mName + " env)\n" +
        "\t\t\t{ super (env); };\n" +
        "\t\tpublic SimObject makeEntity ()\n" +
        "\t\t\t{ return new " + sName + " (" + mName + ifBean + ".this); };\n" +
        "\n" +
        "\t}; // inner class\n" +
        "\n" );

             }; // if
        }; // for

        return buf;

    }; // defineInnerClasses


    /**************************************************************
     * Generate code to construct node n.
     *-------------------------------------------------------------
     * @param  n    node to construct
     * @param  buf  code buffer
     */
    private static String genNodeDecl (Node n)
    {
        String buf = new String ();

        String nName = n.nodeName;
        String nType = Node.TYPE_NAME [n.nodeType];

        buf = buf.concat ( "\t" + nType + " \t" + nName + ";\n" );

        return buf;

     }; // genNodeDecl


    /**************************************************************
     * Generate code for node n's properties.
     *-------------------------------------------------------------
     * @param  n      node to construct
     * @param  count  counter
     */
    private static String genNodeProp (Node n, int count)
    {
        String buf   = new String ();
        String nName = n.nodeName;
		String nLocn = new String ();
        int    nType = n.nodeType;
		if (nType < n.SPLIT) 
				nLocn = new String (n.polyg.xpoints [0] + ", " 
					+ n.polyg.ypoints [0]);
		else 
				nLocn = new String ((int)n.oval.x + ", " 
					+ (int)n.oval.y);			
				
        if (count != 0) buf = buf.concat (",");

        buf = buf.concat (  

        "\n\t\tnew Prop (Node." + Node.TYPE_NAME_CAP [nType] + ", "
                       + "\"" + nName + "\", "
                       + n.numTokens + ", "
                       + "new Point (" + nLocn + "), "
                       + "new " + whichVariate (n.distribution, n.alpha,
                                  n.beta, n.stream) + ", "
					   // + n.cost + ", " 
					   + "new " + whichVariate (n.costDistribution, n.costAlpha,
								  n.costBeta, n.costStream) 
					   + ")");

        return buf;

    }; // genNodeProp


    /**************************************************************
     * Generate code to construct node n.
     *-------------------------------------------------------------
     * @param  n      node to construct
     * @param  count  counter
     */
    private static String genNode (Node n, int count)
    {
        String buf = new String ();

        String nName = n.nodeName;
        String nType = Node.TYPE_NAME [n.nodeType];
 
        buf = buf.concat ( 

        "\t\t" + nName + " = new " + nType + " (" +
        count + ", " +
        "defaults [" + count + "], ");                // node properties
 
        switch (n.nodeType) {

        case Node.FACILITY:
            buf = buf.concat ( "new " + n.queueType + " (), " + nName + "Es" );
            break;

        case Node.SERVER:
            buf = buf.concat ( nName + "Es" );
            break;

        case Node.SIGNAL:
            buf = buf.concat ( n.queueType + ", " +  nName + "Es" );
            break;

        case Node.SOURCE:
            buf = buf.concat ( "\"" + nName + "\", " + nName + "Es" );
            break;

		case Node.SPLIT:
			buf = buf.concat ( "\"" + nName + "\", " + nName + "Es" );
			break;

		case Node.ANDJOIN:
			buf = buf.concat ( nName + "Es" );
			break;

        case Node.SINK:
            buf = buf.concat ( "null" );
            break;

        default:
			trc.warning ( "invalid node type" );	 
            // trc.tell ("genNode", "invalid node type");
        }; // switch

	buf = buf.concat(", sharedQueue);\n");
	
        return buf;

     }; // genNode


    /**************************************************************
     * Generate code to contruct outgoing edges from node n.
     *-------------------------------------------------------------
     * All nodes must have an outdegree of at least 1.
     * Don't call if node type is Node.SINK (have no outgoing edges).
     * @param  n    node to construct
     * @param  buf  code buffer
     */
    private static String genOutEdges (Node n)
    {
        int ax, ay, bx, by, cx, cy;
        String buf = new String ();

        String nName     = n.nodeName;
        int    outDegree = n.numOutEdges;

        if (outDegree <= 0) {
			trc.warning ( "outDegree = " + outDegree );
            // trc.tell ("genOutEdges", "outDegree = " + outDegree);
        }; // if

        /**********************************************************
         * Construct a transport for each edge e.
         */  
        for (int j = 0; j < outDegree; j++) {
            QCurve e     = n.outEdge [j];
            String eName = new String (nName + "E" + j);

            ax = (int) e.x1;
            ay = (int) e.y1;
            cx = (int) e.x2;
            cy = (int) e.y2;

            if ( e.straight ) {
                buf = buf.concat (

                     "\tstatic Transport    " + eName + " = new Transport (" + ax + ", " + ay + ", " +
                                                                           cx + ", " + cy 
																		   + ", new "
																		   + e.distribution
																		   + " ("
																		   + e.alpha
																		   + ", "
																		   + e.beta
																		   + ", "
																		   + e.stream
																		   + "));\n" );
               transList.add(eName);
            } else {
                bx = (int) e.ctrlx;
                by = (int) e.ctrly;

                buf = buf.concat (

                     "\tstatic Transport    " + eName + " = new Transport (" + ax + ", " + ay + ", " +
                                                                           bx + ", " + by + ", " +
                                                                           cx + ", " + cy + 
																		   ", new Uniform (1000.0, 50.0, 0));\n" );
                transList.add(eName);                                                                           
            };  // if
        }; // for

        /**********************************************************
         * Initial array to hold all edges enimating from node n.
         */  
        buf = buf.concat (

        "\tstatic Transport [] " + nName + "Es = {" + nName + "E0" );

        for (int j = 1; j < outDegree; j++) {
            buf = buf.concat (", " + nName + "E" + j);
        }; // for
        buf = buf.concat ("};\n\n");

        return buf;

    }; // genOutEdges

    /**************************************************************
     * Generate code to construct an array of Transports for the 
     * model.
     */
     private static String genTransArray ()
     {
         String buf = new String ();
         
         buf = buf.concat ("\tstatic Transport [] trans = {");
         for (int j = 0; j < transList.size (); j++) {
             if (j == 0)
                 buf = buf.concat ((String) transList.get (j));
             else
             	 buf = buf.concat (", " + (String) transList.get (j));
         }  // for 
         buf = buf.concat ("};\n\n");
         
         return buf;
         
     } // genTransArray   
     
    /*************************************************************
     * Generate a shared data structure for passing information
     * between the simulation engine and the animator.
     */
     private static String genSharedQueue () 
     {
         String buf = new String ();

         buf = buf.concat( "\n" +
             "\t/**\n" +
             "\t * Define a shared data structure for communication between simulator and animator\n" +
             "\t */\n");         
         
         buf = buf.concat ("\tstatic AnimationQueue sharedQueue = new AnimationQueue ();\n\n");
         
         return buf;
         
     } // genSharedQueue           

    /**************************************************************
     * Generate code to contruct all the nodes for the model.
     *-------------------------------------------------------------
     * @return  String  code to construct all nodes
     */
    private static String genAllNodes ()
    {
        String buf = new String ();

        for (int i = 0; i < numNodes; i++) {
            buf = buf.concat (genNode (node [i], i));
        }; // for

        buf = buf.concat ("\t\tinitModel (new DynamicNode [] { " );

        for (int i = 0; i < numNodes; i++) {
            if (i > 0)  buf = buf.concat (", ");
            buf = buf.concat (node [i].nodeName);
        }; // for

        buf = buf.concat (" });\n");

        return buf;

    }; // genAllNodes


    /**************************************************************
     * Generate code to contruct all the nodes for the model.
     *-------------------------------------------------------------
     * @return  String  code to construct all nodes
     */  
    private static String constructNodes ()
    {
        String buf = new String ();
 
        /**********************************************************
         * Gen: Declare nodes.
         */
        for (int i = 0; i < numNodes; i++) {
            buf = buf.concat (genNodeDecl (node [i]));
        }; // for

        /**********************************************************
         * Gen: Define default properties for each node.
         */
        buf = buf.concat( "\n" +
            "\t/**\n" +
            "\t * Define default properties for each node.\n" +
            "\t */\n" +
            "\tstatic Prop [] defaults = {" );

        for (int i = 0; i < numNodes; i++) {
            buf = buf.concat (genNodeProp (node [i], i));
        }; // for

        buf = buf.concat("};\n");

        /**********************************************************
         * Gen: Define edges leaving each node.
         */
        buf = buf.concat( "\n" +
            "\t/**\n" +
            "\t * Define edges leaving each node.\n" +
            "\t */\n" );

        for (int i = 0; i < numNodes; i++) {
            if (node [i].nodeType != Node.SINK) {
                buf = buf.concat (genOutEdges (node [i]));
            }; // if
        }; // for
 
        return buf;

    }; // constructNodes


    /**************************************************************
     * Generate references connecting entities to models.
     */
    private static String genEnvRefs ()
    {
        String buf = new String ();

        for (Iterator it = entTypeList.iterator (); it.hasNext (); ) {
            buf = buf.concat ("\t\t" + it.next () + ".e_ = model;\n");
        }; // for

        return buf;

    }; // genEnvRefs


    /**************************************************************
     * Generate code for the main model file (e.g., Bank.java).
     */
    private static void genModel ()
    {
        String fileName = new String (currDir + SLASH + mName + ".java");

        try {
            FileWriter fout = new FileWriter (fileName);

            fout.write (

        "\n" +
        "/******************************************************************\n" +
        " * " + mName + ".java\n" +
        " * JSIM "+ mName + " simulation model\n" +
        " */\n" +
        "\n" +
        "import java.awt.*;\n" +
		"import java.util.*;\n" +
        "import jsim.process.*;\n" +
        "import jsim.queue.*;\n" +
        "import jsim.util.*;\n" +
        "import jsim.variate.*;\n" +
        "import jsim.animator.*;\n" +        
        "import jsim.coroutine.*;\n" +        
        "\n" +
        "public class " + mName + " extends Model\n" +
        "{\n" +
        "\t/**\n" +
        "\t * Declare nodes.\n" +
        "\t */\n" +
        constructNodes () +
        genTransArray () +
        genSharedQueue () +
        "\n" +
        "\t/*************************************************************\n" +
        "\t * Construct " + mName + " model.\n" +
        "\t */\n" +
        "\tpublic " + mName + " ()\n" +
        "\t{\n" +
        "\t\tsuper (\"" + mName + "\", defaults, trans, sharedQueue);\n" +
        "\n" +
        genAllNodes () +
        "\n" +
        "\t}; // " + mName + "\n" +
        "\n" +
        "\n" +
        "\t/*************************************************************\n" +
        "\t * Main method for running as application.\n" +
        "\t */\n" +
        "\tpublic static void main (String [] args)\n" +
        "\t{\n" +
        "\t\t" + mName + " model = new " + mName + " ();\n" +
//        genEnvRefs () +
        "\t\tmodel.start ();\n" +
        "\n" +
        "\t}; // main\n" +
        "\n" +
        "}; // class\n" +
        "\n" );
    
            fout.close ();

        } catch (IOException e) {
			trc.warning ( "can't write " + fileName );
            // trc.tell ("genModel", "can't write " + fileName);
        }; // try

    }; // genModel


    /**************************************************************
     * Generate code for the model bean file (e.g., BankBean.java).
     */ 
    /*
     * This method has been commented because ModelBean is not supported
     * in this release of JSIM.
     */ 
//   private static void genModelBean ()
//  {    
//      String fileName = new String (mName + "Bean.java");
//
//      try {
//          FileWriter fout = new FileWriter (fileName);
//
//          fout.write (
//
//      "\n" +
//      "/******************************************************************\n" +
//      " * " + mName + "Bean.java\n" +
//      " * JSIM "+ mName + " simulation model application/bean\n" +
//      " */\n" +
//      "\n" +
//      "import jsim.process.*;\n" +
//      "import jsim.util.*;\n" +
//      "\n" +
//      "public class " + mName + "Bean extends ModelBean\n" +
//      "{\n" +
//      "\t/**********************************************************\n" +
//      "\t * Construct a model bean embedding a model.\n" +
//      "\t */\n" +  
//      "\tpublic " + mName + "Bean ()\n" +
//      "\t{\n" +
//      "\t\tsuper (\"" + mName + "Bean\");\n" +
//      "\n" +
//      "\t}; // " + mName + "Bean\n" +
//      "\n" +
//      "\t/**********************************************************\n" +
//      "\t * Prepare model bean for execution by constructing embedded\n" + 
//      "\t * model.\n" +
//      "\t */\n" +  
//      "\tpublic void prepareModel ()\n" +
//      "\t{\n" +
//      "\t\tif (properties == null) {\n" +
//	"\t\tproperties = " + mName + ".defaults;\n" +
//      "\t\t}; // if\n" +
//      "\t\tmodel = new " + mName + " (properties, this);\n" +
//      "\n" +
//      "\t}; // prepareModel\n" +
//      "\n" +
//      "}; // class\n" +
//      "\n" );
//  
//          fout.close ();
//
//      } catch (IOException e) {
//          trc.tell ("genModelBean", "can't write " + fileName);
//      }; // try
//
//  }; // genModelBean


 
    /**************************************************************
     * Get the index of the node at the end of edge out.
     *-------------------------------------------------------------
     * @param   out  an edge's QCurve
     * @return  int  index of edge's incident node
     */
    private static int getEndNode (QCurve out)
    {
        for (int i = 0; i < numNodes; i++) {
            for (int j = 0; j < node [i].numInEdges; j++) {
                QCurve in = node [i].inEdge [j];
                if (in.x2 == out.x2 && in.y2 == out.y2) {
                    return i;       // found
                }; // if
            }; // for
        }; // for

        return -1;    // not found

    }; // getEndNode


    /**************************************************************
     * Generate code to construct a random variate.
     *-------------------------------------------------------------
     * @param   distrib  distribution
     * @param   alpha    scale parameter
     * @param   beta     shape parameter
     * @param   stream   random number stream
     * @return  String   code for constructing variate
     */
    private static String whichVariate (String distrib,
                                        String alpha,
                                        String beta,
                                        String stream)
    {
        Double   dAlpha;
        Double   dBeta;
        Integer  iStream;
        String   buf = new String (distrib + " (");

        if (distrib.equals ("Variate")) {           // 0-parameter distributions
            try {
                iStream = new Integer (stream);
                buf = buf.concat (iStream.intValue () + ")" );
            } catch(NumberFormatException e) {
            }; // try

        } else if (distrib.equals ("Bernoulli") ||  // 1-parameter distributions
                   distrib.equals ("ChiSquare") ||
                   distrib.equals ("Exponential") ||
                   distrib.equals ("Geometric") ||
                   distrib.equals ("Poisson") ||
                   distrib.equals ("StudentT")) {
            try {
                dAlpha  = new Double  (alpha);
                iStream = new Integer (stream);
                buf = buf.concat (dAlpha.doubleValue () + ", " +
                                  iStream.intValue () + ")" );
            } catch(NumberFormatException e) {
            }; // try

        } else {                                    // 2-parameter distributions
            try {
                dAlpha  = new Double  (alpha);
                dBeta   = new Double  (beta);
                iStream = new Integer (stream);
                buf = buf.concat (dAlpha.doubleValue () + ", " +
                                  dBeta.doubleValue () + ", " + 
                                  iStream.intValue () + ")" );
            } catch(NumberFormatException e) {
            }; // try

        }; // if
      
        return buf;
        
    }; // whichVariate

	/**************************************************************
	 * Recursively generate run-method code for ith split node.
	 *-------------------------------------------------------------
	 * @param   i          index of node
	 * @param   ifCounter  if counter
	 * @param   ifValue    if flag
	 * @param   buf        code buffer
	 * @param   skipSplit  determine whether to skip split in recursive call
	 * @return  String     code for the ith node's run-method
	 */
	private static String genCloneRunNode (int    i,
		int    ifCounter,
		double ifValue,
		String buf,
		boolean skipSplit)
	{
		Node     n      = node [i];
		int      nt     = n.nodeType;
		boolean  ifFlag = false;
		Double   value;
		String   eName;
		int      end;
		int      npar;
		int      tmpend;
		int		 numActiveEdges;
		int		 startingEdge = 0;

		trc.info ( "emit run method code for node " + i +
					"<" + n.nodeName + " [" + nt + "]");
		// trc.show ("genCloneRunNode", "emit run method code for node " + i +
		//	"<" + n.nodeName + " [" + nt + "]");

		marked [i] = true;

		if (nt == Node.SINK) 
		{
			if (n.numOutEdges != 0) 
			{
				trc.warning ( "Sink node may not have outgoing Transports" );
				// trc.tell ("genCloneRunNode", "Sink node may not have outgoing Transports");
			}; // if
		} 
		else if (n.numOutEdges <= 0) 
		{
			trc.warning ( "node " + Node.TYPE_NAME [nt] +
							" must have outgoing Transports");
			// trc.tell ("genCloneRunNode", "node " + Node.TYPE_NAME [nt] +
			//	" must have outgoing Transports");
		}; // if

		/**********************************************************
		 * Generate run method code for node n itself.
		 */
		switch (nt) 
		{

			case Node.SERVER:
			case Node.FACILITY:
				buf = buf.concat ("\t\t\te_." + n.nodeName + ".request (this);\n");
				if (!skipSplit) 
				{
					buf = buf.concat ("\t\t\te_." + n.nodeName + ".use (this);\n");
				} // if
				break;
			case Node.SINK:
			case Node.SPLIT:
			case Node.ANDJOIN:
				if (!skipSplit) {
					buf = buf.concat ("\t\t\te_." + n.nodeName + ".use (this);\n");
				} // if
				break;
			case Node.SIGNAL:
			case Node.SOURCE:
				break;         // exogeneous to entity

			default:
				trc.warning ( "illegal node type " + nt );
				// trc.tell ("genCloneRunNode", "illegal node type " + nt);
		}; //switch

		/**********************************************************
		 * Generate run method code for node n's outgoing edges.
		 */
		trc.info ( "numOutEdges = " + n.numOutEdges );
		// trc.show ("genCloneRunNode", "numOutEdges = " + n.numOutEdges);
		if (n.numOutEdges > 1 && nt != Node.SPLIT) 
		{
			ifFlag = true;
			ifCounter++;
		}; // if
		trc.info ( "ifFlag = " + ifFlag + " ifCounter = " + ifCounter );
		// trc.show ("genCloneRunNode", "ifFlag = " + ifFlag + " ifCounter = " + ifCounter);

		if (nt == Node.SPLIT && skipSplit)    // skip the last edge of a split
		{     
			startingEdge = 1;
			numActiveEdges = n.numOutEdges;
		} 
		else if (nt == Node.SPLIT)           // skip the fist edge of a split
		{
			numActiveEdges = n.numOutEdges - 1;
		} 
		else 
		{
			numActiveEdges = n.numOutEdges;
		} // if

		/**********************************************************
		 * Generate the correct if-elseif-else relation.
		 */
		
		for (int j = startingEdge; j < numActiveEdges; j++) 
		{

			end = getEndNode (n.outEdge [j]);
			unseen [end]--;

			trc.info ( "Edge " + j + " = (" + i + ", " + end + ")" );
			// trc.show ("genCloneRunNode", "Edge " + j + " = (" + i + ", " + end + ")");
            
			if (ifFlag) 
			{

				/**************************************************
				 * First out edge.
				 */
				if (j == 0) 
				{
					value   = new Double (n.outCondition [0]);
					ifValue = value.doubleValue ();

					buf  = buf.concat (

						"\n\t\tdouble prob" + ifCounter + " = branch.gen ();\n" +
						"\t\tif (prob" + ifCounter+ " < " + n.outCondition [0] + ") {\n\n");

					ifSign++;

					/**************************************************
					 * Last out edge.
					 */
				} 
				else if (j < n.numOutEdges - 1) 
				{
					value    = new Double (n.outCondition [j]);
					ifValue += value.doubleValue ();
					value    = new Double (ifValue);
					npar     = ifSign - ifCounter;

					if (npar == -1 ) 
					{

						buf = buf.concat (

							"\n\t\t else if (prob" + ifCounter + " < " + value.toString () + ") {\n\n" );

					} 
					else if (npar >= 0 ) 
					{
						for (int k = 0; k < npar - 1; k++) 
						{
							buf = buf.concat (" }");
						}; // for

						buf = buf.concat (

							"\n\t\t} else if (prob" + ifCounter + " < " + value.toString () + ") {\n\n" );

					} 
					else 
					{
						trc.warning ( "malformed graph" );
						// trc.tell ("genCloneRunNode", "malformed graph");
					}; // if

					/**************************************************
					 * Other out edges.
					 */
				} 
				else 
				{
					npar = ifSign - ifCounter;
					if (npar == -1) 
					{
						buf = buf.concat ("\n\t\t else {\n\n");
					} 
					else if (npar >= 0) 
					{
						for (int k = 0; k < npar - 1; k++) 
						{
							buf = buf.concat (" }");
						}; // for
						buf = buf.concat ("\n\t\t} else {\n\n");
					} 
					else 
					{
						trc.warning ( "malformed graph" );
						// trc.tell ("genCloneRunNode", "malformed graph");
					}; // if

				}; // if

			}; // if

			/**********************************************************
			 * Generate code move along transport.
			 */
			eName = new String (n.nodeName + "E" + j);

			buf = buf.concat (

				"\t\t\tfor (e_." + eName + ".join (this);\n" +
				"\t\t\t     e_." + eName + ".move (this); );\n" );

			if (node [end].nodeType == Node.SINK) 
			{
				trc.info ( "sink = " + end + ", " + marked [end] +
							", " + unseen [end]); 
				// trc.show ("genCloneRunNode", "sink = " + end + ", " + marked [end] +
				//	", " + unseen [end]); 
			}; // if

			/**********************************************************
			 * Decide the next node should be generated.
			 */
			if ( ! marked [end]) 
			{
				trc.info ( "unseen [" + end + "] = " + unseen [end] );
				// trc.show ("genCloneRunNode", "unseen [" + end + "] = " + unseen [end]);
				tmpend = nodeQueue.getFront ();
				if (tmpend < 0) 
				{
					tmpend = - tmpend - 1;
				}; // if

				if (tmpend == end) 
				{   // if next node should be generated
					if (nodeQueue.getFront () < 0 && ifSign > 0) 
					{
						buf = buf.concat ("\n\t\t}; // if\n\n");
						ifSign--;
					}; // if
					nodeQueue.dequeue ();
					buf = genCloneRunNode (end, ifCounter, ifValue, buf, false);
				}; // if

			}; // if

		}; // for

		return buf;

	}; // genCloneRunNode

}; // class


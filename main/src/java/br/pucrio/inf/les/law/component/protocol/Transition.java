package br.pucrio.inf.les.law.component.protocol;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import br.pucrio.inf.les.law.communication.Message;
import br.pucrio.inf.les.law.component.ElementDescriptorKeeper;
import br.pucrio.inf.les.law.component.constraint.AbstractConstraint;
import br.pucrio.inf.les.law.component.constraint.Constraint;
import br.pucrio.inf.les.law.component.constraint.IConstraint;
import br.pucrio.inf.les.law.component.message.MessageDescriptor;
import br.pucrio.inf.les.law.component.norm.NormExecution;
import br.pucrio.inf.les.law.event.Event;
import br.pucrio.inf.les.law.event.Masks;
import br.pucrio.inf.les.law.execution.Context;
import br.pucrio.inf.les.law.execution.IDescriptor;
import br.pucrio.inf.les.law.execution.IExecution;
import br.pucrio.inf.les.law.model.Id;
import br.pucrio.inf.les.law.model.LawException;

public class Transition extends ElementDescriptorKeeper implements IConstraint{

	/**
	 * Logger for this class
	 */
	private static final Log LOG = LogFactory.getLog(Transition.class);

	private Id id;

	private State from;

	private State to;

	/**
	 * Id - Identifier of the element which generated the event.<br>
	 * Integer - The event type generated by the element.
	 */
	private Id activationId;

	private int activationType;

	private ProtocolDescriptor protocol;

	private List<Constraint> constraints;
	

	public Transition(Id id, State from, State to, ProtocolDescriptor protocol)
			throws LawException {
		this.id = id;
		this.from = from;
		this.from.addOutgoingTransition(this);
		this.to = to;
		this.protocol = protocol;
		this.constraints = new ArrayList<Constraint>();

	}

	public State fire(Event event, Context context) throws LawException {
		// Checking pre-conditions
		if (context == null) {
			throw new LawException(
					"There is no execution context for transition "
							+ toString(),
					LawException.MISSING_EXECUTION_CONTEXT);
		}
		if (event == null) {
			throw new LawException("Cannot generate/propagate a null event",
					LawException.MISSING_EVENT);
		}

		if (Masks.MESSAGE_ARRIVAL == event.getType()) {
			// Gets the descriptor for the message
			MessageDescriptor messageDescriptor = protocol
					.getMessageDescriptor(activationId);
			// Verifies if the sent message matches the template message
			if (messageDescriptor.matches((Message) event
					.getEventContent(Event.MESSAGE))) {
				// it matches, so the event generator id is set
				event.setEventGeneratorId(activationId);
			}
		}

		// End checking
		int eventType = event.getType();
		Id generatorId = event.getEventGeneratorId();

		if (!(eventType == activationType && generatorId == activationId)) {
			return null;
		}

		if ((!checkNorms(event, context, getActivatedDescriptors(), true))
				|| (!checkNorms(event, context,getDeactivatedDescriptors(), false))) {
			//Verifica as normas que precisam estar ativas
			// Verifica as normas que precisam estar desativas
			LOG.info("Transição não pode ser ativada porque não está em conformidade com as normas.");
			return null;
		} else if ((!checkConstraints(event.getContent()))) {
			//Verifica os constraints que precisam estar ok
			LOG.info("Transição não pode ser ativada porque não está em conformidade com as constraints.");
			return null;
		} else {
			// OK tudo foi verificado, a transição pode ocorrer.
			
			Event transitionActivationEvent = new Event(getId(),Masks.TRANSITION_ACTIVATION, getId());
			transitionActivationEvent.addEventContent(Event.MESSAGE,event.getEventContent(Event.MESSAGE));
			LOG.debug("Transition [" + getId() + "] fired because of generatorId " + getId()+ " and message attached " + event.getEventContent(Event.MESSAGE) + ".");
			// Avisa ao gerenciador de eventos que a transição foi disparada.
			context.fire(transitionActivationEvent);

			// Once reached a final state, it generates a Final State Reached
			// Event.
			if (to.isSuccess()) {
				LOG
						.debug("Transition [" + getId()
								+ "] reached a final state.");
				context.fire(new Event(Masks.SUCCESSFUL_STATE_REACHED, id));
			} else if (to.isFailure()) {
				LOG.debug("Transition [" + getId()
						+ "] reached a failure state.");
				context.fire(new Event(Masks.FAILURE_STATE_REACHED, id));
			} 

			return to;
		}
	}

	private boolean checkNorms(Event event, Context context,
			List<IDescriptor> norms, boolean enabled) {

		for (IDescriptor norm : norms) {

			if (enabled) {
				/*
				 * Verifica com o gerenciador de normas se a norma está
				 * desativa. Caso ela realmente esteja desativa retorna null
				 * pois ela precisaria estar ativa.
				 */

				// Pega as intancias das normas que foram ativadas no contexto
				// da cena
				// na qual esta transicao esta rodando.
				List<IExecution> normsExecution = context
						.getExecutionsByDescriptorId(norm.getId());
				if (normsExecution == null) {
					LOG.debug("Transition [" + getId()
							+ "] didn't fire, the norm [" + norm
							+ "] should've been active.");
					return false;

				} else {

					if (Masks.MESSAGE_ARRIVAL == event.getType()) {
						// se a transição foi ativada por um evento
						// message_arrival

						// para cada norma, verificar se ela está ativa para o
						// sender
						// da mensagem que ativou esta transição
						Message msg = (Message) event.getContent().get(
								Event.MESSAGE);
						for (int i = 0; i < normsExecution.size(); i++) {
							NormExecution normExecution = (NormExecution) normsExecution
									.get(i);
							if (normExecution.containsAgentId(msg.getSender())) {
								return true;
							}
						}
						return false;
					} else if (Masks.CLOCK_ACTIVATION == event.getType()
							|| Masks.CLOCK_DEACTIVATION == event.getType()) {
						// se a transição foi ativada por um clock
						// basta ter uma execution da norma no contexto
						return true;
					}
				}

			} else {
				/*
				 * Verifica com o gerenciador de normas se a norma está ativa.
				 * Caso ela realmente esteja ativa retorna false pois ela
				 * precisaria estar desativa.
				 */

				// Pega as intancias das normas que foram ativadas no contexto
				// da cena
				// na qual esta transicao esta rodando.
				List<IExecution> normsExecution = context
						.getExecutionsByDescriptorId(norm.getId());
				if (normsExecution == null) {
					return true;
				} else {

					if (Masks.MESSAGE_ARRIVAL == event.getType()) {
						// se a transição foi ativada por um evento
						// message_arrival

						// para cada norma, verificar se ela está ativa para o
						// sender
						// da mensagem que ativou esta transição
						Message msg = (Message) event.getContent().get(
								Event.MESSAGE);
						for (int i = 0; i < normsExecution.size(); i++) {
							NormExecution normExecution = (NormExecution) normsExecution
									.get(i);
							if (normExecution.containsAgentId(msg.getSender())) {
								LOG.debug("Transition [" + getId()
										+ "] fired, the norm [" + norm
										+ "] should've been deactive.");
								return false;
							}
						}
						return true;
					} else if (Masks.CLOCK_ACTIVATION == event.getType()
							|| Masks.CLOCK_DEACTIVATION == event.getType()) {
						// se a transição foi ativada por um clock
						// basta ter uma execution da norma no contexto
						return false;
					}
				}
			}
		}

		return true;
	}
	
	
	public boolean checkConstraints(Map<String, Object> parameters){
		for (Constraint constraint : constraints) {
			AbstractConstraint realConstraint = null;
			try {
				realConstraint = (AbstractConstraint) constraint.makeConstraint(new HashMap<String, Object>());
			} catch (LawException e) {
				e.printStackTrace();
			}
			if (realConstraint.constrain(parameters)){
				LOG.debug("Transition ["+this.getId()+"] have not been fired because the constraint: "+constraint);
				return false;
			}
		}
		return true;
	}

	/**
	 * @return Returns the id.
	 */
	public Id getId() {
		return id;
	}

	/**
	 * @param id
	 *            The id to set.
	 */
	public void setId(Id id) {
		this.id = id;
	}

	/**
	 * Given a generatorId, returns the event type in which activates the firing
	 * of this transition
	 * 
	 * @param generatorId
	 * @return
	 */
	// public int getEventTypeInActivationCondition(Id generatorId ){
	// return activations.get(generatorId);
	// }
	public void addActivationCondition(Id generatorId, int eventType)
			throws LawException {
		this.activationId = generatorId;
		this.activationType = eventType;
	}

	public String toString() {
		return "[" + id.toString() + "] " + from.toString() + " --> "
				+ to.toString();
	}

	public State getFrom() {
		return from;
	}

	public State getTo() {
		return to;
	}

	public Id getActivationId() {
		return activationId;
	}

	public int getActivationType() {
		return activationType;
	}

	public void addConstraint(Constraint constraint) {
		constraints.add(constraint);
	}
}
